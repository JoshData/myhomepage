<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">

    <title>Iceberger</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Oswald&family=Oxygen:wght@400&family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">

    <style>
      body {
        padding: 50px 0;
        font-family: 'Oxygen', sans-serif;
        font-size: 12pt;
      }

      h1 {
        font-weight: bold;
        font-family: 'Oswald', sans-serif;
      }

      p.subhead {
        font-size: 140%;
        margin-bottom: 0;
      }
      p.subhead2 {
        margin-bottom: 50px;
      }

      strong {
        font-family: 'Oswald', sans-serif;
        font-size: 15pt;
        letter-spacing: .5px;
      }

      a, a:visited, a:focus {
        color: #2c7bb6;
      }

      #canvas {
        border: 2px solid black;
        width: 100%;
        height: 20em;
        background-color: black;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <div class="container-md" style="max-width: 50em">

    <h1>Iceberger</h1>
    <p class="subhead">Draw an iceberg and see how it will float.</p>
    <p class="subhead2">(Inspired by a <a href="https://twitter.com/GlacialMeg/status/1362557149147058178?ref_src=twsrc%5Etfw">tweet by @GlacialMeg</a>)</p>

    <canvas id="canvas">
    </canvas>

    <p style="margin: 25px 0; color: #554;">Icebergs are less dense than water, so they always float with about 10% of their mass above the water. But which way up? An iceberg wouldn&rsquo;t float <i>exactly</i> like on this page in reality. Its three-dimensional distribution of mass and its relative density compared to the water are both significant factors that are only approximated here.</p>

    <hr style="margin: 45px 0 50px 0">

    <p>Inspired by a tweet by @GlacialMeg:</p>
    <blockquote class="twitter-tweet" data-partner="tweetdeck"><p lang="en" dir="ltr">Today I channeled my energy into this very unofficial but passionate petition for scientists to start drawing icebergs in their stable orientations. I went to the trouble of painting a stable iceberg with my watercolors, so plz hear me out.<br><br>(1/4) <a href="https://t.co/rtkCYub38b">pic.twitter.com/rtkCYub38b</a></p>&mdash; Megan Thompson-Munson (@GlacialMeg) <a href="https://twitter.com/GlacialMeg/status/1362557149147058178?ref_src=twsrc%5Etfw">February 19, 2021</a></blockquote>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>


    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.bundle.min.js" integrity="sha384-ygbV9kiqUc6oa4msXn9868pTtWMgiQaeYH7/t7LECLbyPA2x65Kgf80OJFdroafW" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@5/turf.min.js"></script>

    <script>
        $(function() {
            // Make the canvas nicely sized.
            var h = $("#canvas").width() * 9/16;
            if (h > $(window).height() - 50) h = $(window).height() - 50;
            $("#canvas").height(h);

            // Set the canvas coordinate system to match page units.
            $("#canvas").attr("width", $("#canvas").width());
            $("#canvas").attr("height", $("#canvas").height());

            // Get the water level.
            var yZero = $("#canvas").height() / 3;
            var ctx = document.getElementById('canvas').getContext("2d");

            // Draw backgound.
            function draw_background() {
                // Sky
                ctx.beginPath();
                ctx.fillStyle = "#bbddee";
                ctx.moveTo(0, 0);
                ctx.lineTo(0, ctx.canvas.height);
                ctx.lineTo(ctx.canvas.width, ctx.canvas.height);
                ctx.lineTo(ctx.canvas.width, 0);
                ctx.closePath();
                ctx.fill();

                // Horizon
                ctx.beginPath();
                ctx.lineWidth = 1;
                ctx.strokeStyle = "yellow";
                ctx.moveTo(0, yZero);
                ctx.lineTo(ctx.canvas.width, yZero);
                ctx.closePath();
                ctx.stroke();

                // Sun
                ctx.beginPath();
                ctx.fillStyle = "#fefec4";
                ctx.arc(ctx.canvas.width - 50, 35, 20, 0, 2 * Math.PI);
                ctx.fill();

                // Water
                draw_water();
            }
            function draw_water() {
                // Water
                ctx.beginPath();
                ctx.fillStyle = "#2c7bb6";
                ctx.moveTo(0, yZero);
                ctx.lineTo(0, ctx.canvas.height);
                ctx.lineTo(ctx.canvas.width, ctx.canvas.height);
                ctx.lineTo(ctx.canvas.width, yZero);
                ctx.closePath();
                ctx.fill();
            }
            draw_background();
            draw_water();

            // Hook up draw events.
            var mousePressed = false;
            var polygon = null;
            var polygonProperties = null;
            var velocity = [];
            function add_point(e) {
                if (e.touches)
                    e = e.touches[0];

                var rect = $("#canvas")[0].getBoundingClientRect();
                var x = e.clientX - rect.left;
                var y = e.clientY - rect.top;
                polygon.push([x, y]);

                // Draw lasso.
                if (polygon.length >= 2) {
                    ctx.beginPath();
                    ctx.strokeStyle = "black";
                    ctx.lineWidth = 3;
                    ctx.lineJoin = "round";
                    ctx.moveTo(polygon[polygon.length-2][0], polygon[polygon.length-2][1]);
                    ctx.lineTo(polygon[polygon.length-1][0], polygon[polygon.length-1][1]);
                    ctx.closePath();
                    ctx.stroke();
                }
            };
            $('#canvas').on('mousedown touchstart', function (e) {
                // Reset canvas.
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                draw_background();
                draw_water();

                mousePressed = true;
                polygon = [];
                add_point(e);
            });
            $('#canvas').on('mousemove touchmove', function (e) {
                if (mousePressed) {
                    add_point(e);
                    e.preventDefault(); // prevent scrolling on iOS 12
                }
            });
            $('#canvas').on('mouseup touchend', function (e) {
                // Finish drawing - reset the polygon and inertia.
                mousePressed = false;
                if (polygon.length < 3) {
                    polygon = null;
                    return;
                }
                if (polygon.length > 0) // make first and last point the same
                    polygon.push(polygon[0]);

                // Reset the velocity vector.
                velocity = [0, 0, 0];

                // People like to draw shapes with kinks, which results
                // in part of the polygon being treated as negative area.
                // turf.unkinkPolygon can be used to find the kinks and
                // separate the polygon into multiple polygons at the
                // kinks, but it's a little fragile and hard to combine
                // into a single unkinked polygon. We also want to avoid
                // showing errors when there are just small degenerate
                // kinds from messy drawing.
                // (If turf.kinks(turf.polygon([polygon])).features.length
                // is non-zero, there are kinks. We could show an error,
                // but that's not friendly.)
                try {
                    // Remove duplicate vertices which breaks unkinkPolygon.
                    var found_vertices = { };
                    var polygon2 = [];
                    polygon.forEach(function(pt) {
                        var k = pt[0] + "|" + pt[1];
                        if (k in found_vertices) return;
                        found_vertices[k] = true;
                        polygon2.push(pt);
                    })
                    polygon = polygon2;
                    polygon.push(polygon[0]);

                    // Split polygon into parts separated at kinks.
                    var k = turf.polygon([polygon]);
                    k = turf.unkinkPolygon(k);
                    if (k.features.length > 1) {
                        // Take the part with the largest area.
                        k = k.features.map(function(kk) { return kk.geometry.coordinates[0]; })
                        var areas = k.map(polygonArea);
                        var maxArea = 0, maxAreaIndex = 0;
                        areas.forEach(function(area, i) {
                            if (area > maxArea) {
                                maxArea = area;
                                maxAreaIndex = i;
                            }
                        });
                        polygon = k[maxAreaIndex];
                    }
                } catch (e) {
                }

                // Make the polygon defined in a consistent clockwise/counter-clockwise
                // order to simplify the computation of the fun drag effect.
                polygonProperties = {
                  area: signedPolygonArea(polygon),
                };
                if (polygonProperties.area < 0) {
                    polygon = polygon.reverse();
                    polygonProperties.area = Math.abs(polygonProperties.area);
                }

                // Calculate the polygon's angular mass, normalized to
                // the polygon area because it plays nicer when the
                // math is size-independent.
                polygonProperties.rotationalInertia = polygonMomentOfInertia(polygon) / polygonProperties.area**.5 / 1000000;
            });


            var tick_repeat = function() {
                tick();
                setTimeout(tick_repeat, 50);
            }
            tick_repeat();

            function tick() {
                if (!polygon || polygon.length < 4 || mousePressed
                   || !polygonProperties)
                    return;

                // Compute the force on centroid of the iceberg polygon
                // at this time instant. The polygon has three degrees
                // of freedom: x, y, and rotation.
                var force = [0, 0, 0];

                // Compute the center of mass of the iceberg and the
                // center of mass of the submerged portion.
                var pc = centroid(polygon);
                var polygon_submerged = turf.bboxClip(turf.polygon([polygon]),
                    [-Infinity, yZero, Infinity, Infinity]).geometry.coordinates[0];
                var pc_submerged = (polygon_submerged && polygon_submerged.length >= 4) ? centroid(polygon_submerged) : [0, 0];

                // The vector between the two centroids determines a
                // force that is applied. Gravity pulls down (+y because
                // the canvas coordinates are upside-down) at the
                // center of mass of the full iceberg and bouyancy
                // pushes up (-y) at the center of mass of the submerged
                // portion.
                var specific_gravity = .85;
                var fg = 1;
                var submerged_ratio = polygonArea(polygon_submerged) / polygonProperties.area;
                var fb = submerged_ratio / specific_gravity;
                force[1] += fg - fb;

                // In reality, the 3D distribution of mass is not uniform
                // across the 2D projection of the iceberg that we are looking
                // at. While we can assume that it's close, when we chop off
                // the top of the iceberg to find the submerged portion,
                // the centroid of the submerged portion is likely to be closer
                // to the total centroid than the centroid of the projection of
                // the submerged part because what we chop off is always close
                // to an edge and the edges have lower density than in the middle.
                // Adjust the centroid location of the submerged part accordingly.
                // When half-way submerged, move the centroid 20% closer to the
                // full cenroid.
                var r = (submerged_ratio < .5 ? submerged_ratio : (1 - submerged_ratio)) * 2 * .2;
                pc_submerged[0] = pc_submerged[0]*(1-r) + pc[0]*r;
                pc_submerged[1] = pc_submerged[1]*(1-r) + pc[1]*r;

                // Apply a moment at the centroid of the iceberg due to
                // the eccentricity between the iceberg centroid and the
                // centroid of the submerged portion where the bouyant
                // force acts.
                force[2] += fb * (pc_submerged[0] - pc[0]);

                // Apply some drag. This may not be totally scientifically valid.
                // For each line segment on the perimeter of the polygon that is
                // facing the direction of motion (i.e. its perpendicular points
                // in the direction of motion), apply a force equal to the dot
                // product of the velocity and the perpendicular (i.e. 0 when
                // the face and the velocity are parallel, maximal when they are
                // perpendicular). Apply this force at the midpoint of the segment
                // perpendicular to the segment. Transform the force to the centroid
                // of the polygon.
                var perimeter = 0;
                polygon.forEach(function(p1, i) {
                    if (i == 0) return;
                    var p0 = polygon[i-1];
                    var v = [p1[0]-p0[0], p1[1]-p0[1]];
                    var d = (v[0]**2 + v[1]**2)**.5;
                    perimeter += d;
                });
                polygon.forEach(function(p1, i) {
                    if (i == 0) return;
                    var p0 = polygon[i-1];

                    // Get the perpendicular facing *outward* 
                    // (away from the polygon).
                    var v = [p1[0]-p0[0], p1[1]-p0[1]];
                    v = [v[1], -v[0]]; // perpendicular (easy in 2D)

                    // Normalize the vector so that the total force
                    // from all line segments is 1 but each line
                    // segment contributes proportionally to its
                    // length.
                    v[0] /= perimeter;
                    v[1] /= perimeter;

                    // Compute the force as the dot product of the perpendicular
                    // with the velocity.
                    // Skip if the force is negative which means the
                    // line segment is not on the front side of the polygon
                    // w.r.t. the direction of motion.
                    var f = v[0]*velocity[0] + v[1]*velocity[1];
                    if (f < 0) return;

                    // Scale the force. There's more drag under water.
                    f *= (1 + 2 * submerged_ratio);

                    // Apply this force in the opposite direction of the
                    // perpendicular, i.e. into the iceberg.
                    f = [-v[0] * f, -v[1] * f];

                    // Apply to the force vector. Skip Fy because we
                    // don't want actual drag --- we handle that by
                    // damping.
                    force[0] += f[0];
                    //force[1] += f[1];

                    // Transform the force from the center of the segment
                    // to the centroid. Limit the applied moment.
                    var p = [(p0[0] + p1[0])/2, (p0[1] + p1[1])/2];
                    m = f[0] * (p[1] - pc[1]) - f[1] * (p[0] - pc[0]);
                    if (Math.abs(m) > 1) m = Math.sign(m) * 1;
                    force[2] += m;
                });

                // If the polygon is out of the horizontal bounds, push it in.
                var minx = Infinity, maxx = -Infinity;
                polygon.forEach(function(pt) {
                    if (pt[0] < minx) minx = pt[0];
                    if (pt[0] > maxx) maxx = pt[0];
                });
                if (minx < 0) force[0] += -minx/ctx.canvas.width * 10;
                if (maxx > ctx.canvas.width) force[0] += (ctx.canvas.width-maxx)/ctx.canvas.width * 10;

                // The translational force is normalized to the polygon area so we can
                // consider it an acceleration. Increment the velocity with the acceleration.
                velocity[0] += force[0];
                velocity[1] += force[1];

                // But the rotational force must be divided by the polygon's angular mass.
                velocity[2] += force[2] / polygonProperties.rotationalInertia;

                // Apply damping. There is more damping in water than in air.
                // Lowering the damping in air boosts the free-fall a bit for
                // a nice effect when it hits the water.
                var damping_air = .99;
                var damping_water = .94;
                var damping = damping_air*(1-submerged_ratio) + damping_water*submerged_ratio;
                velocity[0] *= damping;
                velocity[1] *= damping;
                velocity[2] *= (damping-.1);

                // Apply velocity to the coordinates.
                polygon = polygon.map(function(pt) {
                    pt = rotate(pc[0], pc[1], pt[0], pt[1], velocity[2]);
                    pt[0] += velocity[0];
                    pt[1] += velocity[1];
                    return pt;
                });

                // Melt the iceberg slowly. Melt faster above water.
                polygon.forEach(function(pt) {
                    if (pt[1] < yZero)
                        pt[1] = (pt[1] - yZero)*.9999 + yZero;
                    else
                        pt[1] = (pt[1] - yZero)*.99999 + yZero;
                });

                // Reset canvas.
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                // Draw polygon as a filled iceberg.
                // TODO: Draw ice texture?
                draw_background();
                ctx.strokeStyle = "black";
                ctx.fillStyle = "white";
                ctx.lineWidth = 2;
                ctx.lineJoin = "round";
                ctx.beginPath();
                ctx.moveTo(polygon[0][0], polygon[0][1]);
                polygon.forEach(function(pt) {
                    ctx.lineTo(pt[0], pt[1]);
                });
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // water overlay over the submerged part
                ctx.globalAlpha = .5;
                draw_water();
                ctx.globalAlpha = 1;
            }           
        })

        function centroid(pts) {
            // https://stackoverflow.com/a/33852627
            var nPts = pts.length;
            var off = pts[0];
            var twicearea = 0;
            var x = 0;
            var y = 0;
            var p1,p2;
            var f;
            for (var i = 0, j = nPts - 1; i < nPts; j = i++) {
                p1 = pts[i];
                p2 = pts[j];
                f = (p1[0] - off[0]) * (p2[1] - off[1]) - (p2[0] - off[0]) * (p1[1] - off[1]);
                twicearea += f;
                x += (p1[0] + p2[0] - 2 * off[0]) * f;
                y += (p1[1] + p2[1] - 2 * off[1]) * f;
            }
            f = twicearea * 3;
            return [ x / f + off[0], y / f + off[1] ];
        }

        function signedPolygonArea(vertices) {
            if (!vertices || vertices.length < 4) return 0;
            // https://stackoverflow.com/a/33670691
            var total = 0;
            for (var i = 0, l = vertices.length; i < l; i++) {
              var addX = vertices[i][0];
              var addY = vertices[i == vertices.length - 1 ? 0 : i + 1][1];
              var subX = vertices[i == vertices.length - 1 ? 0 : i + 1][0];
              var subY = vertices[i][1];

              total += (addX * addY * 0.5);
              total -= (subX * subY * 0.5);
            }
            return total;
        }
        function polygonArea(vertices) {
            return Math.abs(signedPolygonArea(vertices));
        }

        function rotate(cx, cy, x, y, angle) {
            // https://stackoverflow.com/a/17411276
            var radians = (Math.PI / 180) * angle,
                cos = Math.cos(radians),
                sin = Math.sin(radians),
                nx = (cos * (x - cx)) + (sin * (y - cy)) + cx,
                ny = (cos * (y - cy)) - (sin * (x - cx)) + cy;
            return [nx, ny];
        }

        function polygonMomentOfInertia(points) {
          // Thanks to https://fotino.me/moment-of-inertia-algorithm/.
          function sub(p1, p2) {
            return [p1[0] - p2[0], p1[1] - p2[1]];
          }
          function add(p1, p2) {
            return [p1[0] + p2[0], p1[1] + p2[1]];
          }
          function mul(p, f) {
            return [p[0] * f, p[1] * f];
          }
          function dot(p1, p2) {
            return p1[0] * p2[0] + p1[1] * p2[1];
          }
          function cross(p1, p2) {
            return p1[0] * p2[1] - p2[0] * p1[1];
          }
          function dist(p1, p2) {
            p2 = p2 || [0, 0];
            const x = p1[0] - p2[0], y = p1[1] - p2[1];
            return Math.sqrt(x * x + y * y);
          }
          let momentOfInertia = 0;
          for (let i = 1; i < points.length - 1; i++) {
            const p1 = points[0], p2 = points[i], p3 = points[i + 1];
            
            const w = dist(p1, p2);
            const w1 = Math.abs(dot(sub(p1, p2), sub(p3, p2)) / w);
            const w2 = Math.abs(w - w1);
            
            const signedTriArea = cross(sub(p3, p1), sub(p2, p1)) / 2;
            const h = 2 * Math.abs(signedTriArea) / w;
            
            const p4 = add(p2, mul(sub(p1, p2), w1 / w));
            
            const cm1 = [
              (p2[0] + p3[0] + p4[0]) / 3,
              (p2[1] + p3[1] + p4[1]) / 3
            ];
            const cm2 = [
              (p1[0] + p3[0] + p4[0]) / 3,
              (p1[1] + p3[1] + p4[1]) / 3
            ];
            
            const I1 = w1 * h * ((h * h / 4) + (w1 * w1 / 12));
            const I2 = w2 * h * ((h * h / 4) + (w2 * w2 / 12));
            const m1 = 0.5 * w1 * h;
            const m2 = 0.5 * w2 * h;

            const I1cm = I1 - (m1 * Math.pow(dist(cm1, p3), 2));
            const I2cm = I2 - (m2 * Math.pow(dist(cm2, p3), 2));
            
            const momentOfInertiaPart1 = I1cm + (m1 * Math.pow(dist(cm1), 2));
            const momentOfInertiaPart2 = I2cm + (m2 * Math.pow(dist(cm2), 2));
            if (cross(sub(p1, p3), sub(p4, p3)) > 0) {
              momentOfInertia += momentOfInertiaPart1;
            } else {
              momentOfInertia -= momentOfInertiaPart1;
            }
            if (cross(sub(p4, p3), sub(p2, p3)) > 0) {
              momentOfInertia += momentOfInertiaPart2;
            } else {
              momentOfInertia -= momentOfInertiaPart2;
            }
          }
          return Math.abs(momentOfInertia);
        }                

    </script>

  </body>
</html>
